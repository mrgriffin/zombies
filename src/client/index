<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Game example</title>
<style>
#ping { position: absolute; top: 0; left: 550px; }
</style>
</head>
<body>
<canvas id="viewport" width="500" height="500"></canvas>
<span id="ping"></span>
<br><input id="name" type="text"><input id="join" type="button" value="Join">
<script>
var self = null;
var players = {};
var walls = [];
var enemies = [];
var shots = [];

function Player(name, x, y, vx, vy, health) {
	this.name = name; this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.health = health;
}

Player.prototype.setState = function (x, y, vx, vy, health) {
	this.x = x; this.y = y; this.vx = vx; this.vy = vy; this.health = health;
};

function Wall(x, y, w, h) {
	this.x = x; this.y = y; this.w = w; this.h = h;
}

function Shot(x, y, vx, vy) {
	this.x = x; this.y = y; this.vx = vx; this.vy = vy;
}

Shot.prototype.setState = function (x, y, vx, vy) {
	this.x = x; this.y = y; this.vx = vx; this.vy = vy;
};

window.addEventListener('keydown', function (e) {
	if (!self) return;
	switch (e.keyCode) {
		case 38: self.iy = self.iu = -1; break; // Up.
		case 39: self.ix = self.ir =  1; break; // Right.
		case 40: self.iy = self.id =  1; break; // Down.
		case 37: self.ix = self.il = -1; break; // Left.
		case 32: self.ia = true;         break; // Space.
	}
	// TODO: Only send an update if our state has changed.
	sendState();
}, false);

window.addEventListener('keyup', function (e) {
	if (!self) return;
	switch (e.keyCode) {
		case 38: self.iu = 0; self.iy = self.id; break; // Up.
		case 39: self.ir = 0; self.ix = self.il; break; // Right.
		case 40: self.id = 0; self.iy = self.iu; break; // Down.
		case 37: self.il = 0; self.ix = self.ir; break; // Left.
		case 32: self.ia = false;                break; // Space.
	}
	// TODO: Only send an update if our state has changed.
	sendState();
}, false);

/* Send messages to the server. */

function joinRoom() {
	var request = new XMLHttpRequest();
	request.onreadystatechange = function () {
		if (request.readyState == 4 && request.status == 200) {
			document.getElementById('name').disabled = true;
			document.getElementById('join').disabled = true;
		}
	};
	request.open('POST', '/join', true);
	request.send(document.getElementById('name').value);
}

document.getElementById('join').addEventListener('click', joinRoom, false);
document.getElementById('name').addEventListener('keydown', function (e) { if (e.keyCode == 13) joinRoom(); }, false);

function sendState() {
	var request = new XMLHttpRequest();
	request.open('POST', '/state', true);
	request.send(self.ix + ',' + self.iy + ',' + self.ia);
}

/* Handle messages from the server. */

function handleJoin(name, x, y, vx, vy, health) {
	players[name] = new Player(name, x, y, vx, vy, health);
	// FIXME: This would allow someone with our name to override us.
	if (name == document.getElementById('name').value) {
		self = players[name];
		self.ix = self.iy = self.iu = self.ir = self.id = self.il = 0;
		self.ia = false;
	}
}

function handleState(name, x, y, vx, vy, health) {
	players[name].setState(x, y, vx, vy, health);
}

function handlePing(ping) {
	document.getElementById('ping').innerHTML = 'Ping: ' + ping;
}

function handleWall(x, y, w, h) {
	walls.push(new Wall(x, y, w, h));
}

function handleEnemy(id, x, y, vx, vy, health) {
	if (!enemies[id]) enemies[id] = new Player(null, x, y, vx, vy, health);
	else enemies[id].setState(x, y, vx, vy, health);
}

function handleEnemyDeath(id) {
	delete enemies[id];
}

function handleShot(id, x, y, vx, vy) {
	if (!shots[id]) shots[id] = new Shot(x, y, vx, vy);
	else shots[id].setState(x, y, vx, vy);
}

function handleShotDeath(id) {
	delete shots[id];
}

function update(failures, maxFailures) {
	var request = new XMLHttpRequest();
	request.onreadystatechange = function () {
		// FIXME: Occasionally we lose the first response.
		if (request.readyState == 4) {
			if (request.status == 200) {
				eval(request.responseText);
			} else {
				failures++;
			}

			if (failures < maxFailures) update(failures, maxFailures);
		}
	};
	request.open('GET', '/update', true);
	request.send(null);
}

update(0, 5);

/* Render. */

var dt = 1 / 60;

// WARNING: Simulation is done here too.
function render() {
	var canvas = document.getElementById('viewport');
	canvas.width = canvas.width;
	var context = canvas.getContext('2d');
	for (var player in players) {
		if (!players.hasOwnProperty(player)) continue;
		var p = players[player];
		p.x += p.vx * dt;
		p.y += p.vy * dt;
		context.fillStyle = 'rgb(' + Math.floor(255 / 100 * p.health) + ',' + Math.floor(127 / 100 * p.health) + ',0)';
		context.beginPath();
		context.arc(p.x, p.y, 12, 0, 2 * Math.PI, false);
		context.fill();
	}

	walls.forEach(function (wall) {
		context.fillStyle = '#000000';
		context.beginPath();
		context.rect(wall.x - wall.w / 2, wall.y - wall.h / 2, wall.w, wall.h);
		context.fill();
	});

	enemies.forEach(function (enemy) {
		enemy.x += enemy.vx * dt;
		enemy.y += enemy.vy * dt;
		context.fillStyle = '#3faf3f';
		context.beginPath();
		context.arc(enemy.x, enemy.y, 12, 0, 2 * Math.PI, false);
		context.fill();
	});

	shots.forEach(function (shot) {
		context.fillStyle = '#7f7fff';
		context.beginPath();
		context.arc(shot.x, shot.y, 4, 0, 2 * Math.PI, false);
		context.fill();
	});
}

setInterval(render, dt * 1000);
</script>
</body>
</html>
